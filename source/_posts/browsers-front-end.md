---
title: browsers-front-end
date: 2017-02-16 17:13:46
tags: [html, css, javascript, browser]
---
# 浏览器加载，解析，渲染

## 了解浏览器加载、解析、渲染过程的意义

> * 了解浏览器如何进行*加载*，可以使我们在引用外部样式文件，外部js时，将它们放到合适的位置，使浏览器以最快的速度将文件加载完毕。
> * 了解浏览器如何进行*解析*，可以使我们在构建DOM结构，组织css选择器时，选择最优的写法，提高浏览器的解析速率。
> * 了解浏览器如何进行*渲染*，明白渲染的过程，我们在设置元素属性，编写js文件时，可以减少重绘，重新布局的消耗。

## 浏览器是如何进行加载，解析，渲染的呢？

* 用户访问网页，DNS服务器（域名解析系统）会根据用户提供的域名查找对应的IP地址，找到后，系统会向对应IP地址的网络服务器发送一个http请求。
* 网络服务器解析请求，并发送请求给数据库服务器。
* 数据库服务器将请求的资源返回给网络服务器，网络服务器解析数据，并生成html文件，放入http response中，返回给浏览器。
* 浏览器解析http response。
* 浏览器解析http response后，需要下载html文件，以及html文件内包含的外部引用文件，以及文件内涉及的图片或者多媒体文件。

<!--more-->

## 加载

  即获取资源文件的过程，不同浏览器，以及他们不同版本在实现这一过程时，会有不同的实现效果（资源之间相互阻塞）。加载过程中遇到外部css文件，浏览器另外发出
一个请求，来获取css文件。遇到图片资源，浏览器也会另外发出请求，来获取图片资源。这是异步请求，不会影响到html文档进行加载，但是当文档加载过程中遇到js文件
，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。

> * 原因：JS有可能会修改DOM，最为经典的document.write，这意味着，在JS执行完成之前，后续所有资源的下载可能是没有必要的，这是js阻塞后续资源下载的根本原因。
> * 方法：可以将外部引用的js文件放在`</body>`前。

虽然css文件的加载不影响js文件的加载，但却影响js文件的执行，即使js文件内只有一行代码，也会造成阻塞。

> * 原因：可能会有`var width = $("#id").width()`，这意味着，js代码执行前，浏览器必须保证css文件已下载和解析完成。这也是css阻塞后续js的根本原因。
> * 方法：当js文件不需要依赖css文件时，可以将js文件放在头部css的前面。

## 解析

* `html文档解析`生成解析树即DOM树，是由dom元素即节点组成，树的根是document对象。
* `css解析`将css文件解析为样式表对象。
* `js解析`

## 渲染

  即为构建渲染树的过程，是原dom树的可视化表示，构建这棵树是为了以正确的的顺序绘制文档内容。
  渲染树和DOM树的关系，不可见的dom元素不会被插入渲染树中。一些节点位置为绝对或浮动定位，这些节点会在文本流之外，因此会在两棵树的不同位置，渲染树标识出
真实的位置，并用一个占位结构标识出他们原来的位置。
  下图表示浏览器渲染展示网页的主流程：
  ![Render stream](https://user-gold-cdn.xitu.io/2017/9/30/5bbd1038b8e6d9501b73e43bab9495cd?imageView2/0/w/1280/h/960)
  
## 渲染最大的难题就是为每一个dom节点计算他的最终样式。

为每一个元素查找到匹配的样式规则，需要遍历整个规则表；
1. 样式数据是非常大的结构，保存数据很耗内存。
2. 选择器迭代太深，造成太多的无用遍历。
3. 样式规则涉及非常复杂的级联，定义了规则的层次。

# 根据对计算样式困难的理解，在编写css样式表时应该注意以下几点：

1. dom深度尽量浅。
2. 减少行内js、css的数量。
3. 使用现代合法的css属性。
4. 不要为id选择器指定类名或是标签，因为id可以唯一确定一个元素。
5. 不要给类选择器指定标签，类，代表具有一类属性的标签，不仅一个，虽然可以实现，但是降低了效率。
6. 避免后代选择符，尽量使用子选择符。原因：子选择符的概率要大于后代元素匹配符。
7. 避免使用通配符。

