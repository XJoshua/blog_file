---
title: browsers-front-end
date: 2017-02-16 17:13:46
tags: [html, css, javascript, browser]
---
# 浏览器加载，解析，渲染

## 了解浏览器加载、解析、渲染过程的意义

> * 了解浏览器如何进行*加载*，可以使我们在引用外部样式文件，外部js时，将它们放到合适的位置，使浏览器以最快的速度将文件加载完毕。
> * 了解浏览器如何进行*解析*，可以使我们在构建DOM结构，组织css选择器时，选择最优的写法，提高浏览器的解析速率。
> * 了解浏览器如何进行*渲染*，明白渲染的过程，我们在设置元素属性，编写js文件时，可以减少重绘，重新布局的消耗。

## 浏览器是如何进行加载，解析，渲染的呢？

* 用户访问网页，DNS服务器（域名解析系统）会根据用户提供的域名查找对应的IP地址，找到后，系统会向对应IP地址的网络服务器发送一个http请求。
* 网络服务器解析请求，并发送请求给数据库服务器。
* 数据库服务器将请求的资源返回给网络服务器，网络服务器解析数据，并生成html文件，放入http response中，返回给浏览器。
* 浏览器解析http response。
* 浏览器解析http response后，需要下载html文件，以及html文件内包含的外部引用文件，以及文件内涉及的图片或者多媒体文件。

<!--more-->

## 浏览器内核

* ### 浏览器组成
1. 用户界面
2. 浏览器内核：浏览器引擎(查询操作渲染引擎的接口)、渲染引擎、js引擎、网络(http请求)
3. 数据存储
4. js引擎(IE9+: Chakra、firefox: monkey、chrome: v8) 
5. 渲染引擎(firefox: gecko、chrome/safari: webkit)
6. 线程：JS引擎线程、GUI渲染引擎、浏览器事件触发引擎、http请求线程、计时器线程、EventLoop轮询处理线程

* ### javascript引擎
js引擎是基于事件驱动的，采用的是单线程运行机制；
js可以操作DOM元素，从而影响到GUI的渲染结果，因此js引擎线程和GUI渲染线程是互斥的；也就是说js引擎处于运行状态时，GUI线程将处于冻结状态；

* ### javascript单线程
javascript引擎负责解释和执行javascript代码的线程只有一个，称为主线程；js还有其他的线程称为工作线程；
主线程上只执行同步任务；
H5提出了Web Worker标准，允许js创建多个线程，但是完全受主线程控制，且不可以操作DOM；

* ### 工作线程
浏览器还有其他线程，例如：
处理ajax的线程，dom时间线程，定时器线程，读写文件的线程等，这些被称为工作线程；这些线程可能存在于js引擎之中或者之外，称为工作线程，工作线程的任务完成后，会推入到一个任务队列；

## Javascript的异步编程
js引擎只执行同步任务，异步任务会有工作线程来执行；

* ### 异步过程
当需要进行异步操作(定时器，ajax请求，dom事件注册)，主线程会发一个异步任务的请求，相应的工作线程接受请求，相应的工作线程接受请求；当工作线程完成工作之后，通知主线程；主线程接收到通知之后，会执行一定的操作(回调函数);

* ### 事件循环
主线程和工作线程之间的通知机制叫做事件循环。
调用栈：主线程执行时生成的调用栈；
任务队列：工作线程完成任务后会把消息推到一个任务队列，消息就是注册时的回调函数；
当调用栈为空时，主线程会从任务队列里取出一条消息并放入当前的调用栈当中执行，主线程会一直重复这个动作直到消息队列为空，这个过程就叫做事件循环；

* ### 渲染线程和js线程的互斥
渲染线程和js线程是互斥的，在js引擎执行时，渲染线程会被挂起

* ### 为什么会阻塞
js在浏览器中需要被下载、解释、执行；html中script标签是阻塞的，也就是说顺序下载、解释、执行；
浏览器会在js执行后决定当前文档是否需要进行重新渲染或者重排；
js引擎线程和GUI线程是互斥的，所以js执行时会阻塞页面的渲染；

下载虽然是异步的，但是执行还是同步的；先出现的script标签一定是先执行的，即使它是最后一个下载完成的；

## 加载

  即获取资源文件的过程，不同浏览器，以及他们不同版本在实现这一过程时，会有不同的实现效果（资源之间相互阻塞）。加载过程中遇到外部css文件，浏览器另外发出一个请求，来获取css文件。遇到图片资源，浏览器也会另外发出请求，来获取图片资源。这是异步请求，不会影响到html文档进行加载，但是当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。

> * 原因：JS有可能会修改DOM，最为经典的document.write，这意味着，在JS执行完成之前，后续所有资源的下载可能是没有必要的，这是js阻塞后续资源下载的根本原因。
> * 方法：可以将外部引用的js文件放在`</body>`前。

虽然css文件的加载不影响js文件的加载，但却影响js文件的执行，即使js文件内只有一行代码，也会造成阻塞。

> * 原因：可能会有`var width = $("#id").width()`，这意味着，js代码执行前，浏览器必须保证css文件已下载和解析完成。这也是css阻塞后续js的根本原因。
> * 方法：当js文件不需要依赖css文件时，可以将js文件放在头部css的前面。

## 解析

* `html文档解析`生成解析树即DOM树，是由dom元素即节点组成，树的根是document对象。
* `css解析`将css文件解析为样式表对象。
* `js解析`

## 渲染

  即为构建渲染树的过程，是原dom树的可视化表示，构建这棵树是为了以正确的的顺序绘制文档内容。
  渲染树和DOM树的关系，不可见的dom元素不会被插入渲染树中。一些节点位置为绝对或浮动定位，这些节点会在文本流之外，因此会在两棵树的不同位置，渲染树标识出真实的位置，并用一个占位结构标识出他们原来的位置。
  下图表示浏览器渲染展示网页的主流程：
  
  ![Render stream](https://user-gold-cdn.xitu.io/2017/9/30/5bbd1038b8e6d9501b73e43bab9495cd?imageView2/0/w/1280/h/960)
  
## 渲染最大的难题就是为每一个dom节点计算他的最终样式。

为每一个元素查找到匹配的样式规则，需要遍历整个规则表；
1. 样式数据是非常大的结构，保存数据很耗内存。
2. 选择器迭代太深，造成太多的无用遍历。
3. 样式规则涉及非常复杂的级联，定义了规则的层次。

# 根据对计算样式困难的理解，在编写css样式表时应该注意以下几点：

1. dom深度尽量浅。
2. 减少行内js、css的数量。
3. 使用现代合法的css属性。
4. 不要为id选择器指定类名或是标签，因为id可以唯一确定一个元素。
5. 不要给类选择器指定标签，类，代表具有一类属性的标签，不仅一个，虽然可以实现，但是降低了效率。
6. 避免后代选择符，尽量使用子选择符。原因：子选择符的概率要大于后代元素匹配符。
7. 避免使用通配符。

